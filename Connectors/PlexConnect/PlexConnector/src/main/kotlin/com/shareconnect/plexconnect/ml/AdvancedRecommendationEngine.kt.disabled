/*
 * Copyright (c) 2025 MeTube Share
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


package com.shareconnect.plexconnect.ml

import com.shareconnect.plexconnect.config.NlpConfig
import com.shareconnect.plexconnect.data.model.PlexMediaItem
import com.shareconnect.plexconnect.service.PlexAiRecommendationService
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlin.math.*
import kotlin.random.Random

/**
 * Advanced recommendation algorithm combining:
 * - Content-based filtering (semantic similarity)
 * - Collaborative filtering (user behavior patterns)
 * - Temporal weighting (recency bias)
 * - Diversity optimization
 * - Personalization learning
 */
class AdvancedRecommendationEngine {
    
    // User behavior tracking
    private val userProfiles = mutableMapOf<String, UserProfile>()
    private val globalWatchStats = mutableMapOf<String, WatchStats>()
    
    // Recommendation weights (learnable)
    private var semanticWeight = 0.5f
    private var collaborativeWeight = 0.3f
    private var temporalWeight = 0.1f
    private var diversityWeight = 0.1f
    
    /**
     * Get personalized recommendations for a user
     */
    suspend fun getPersonalizedRecommendations(
        userId: String,
        candidateItems: List<PlexMediaItem>,
        enhancedItems: List<PlexAiRecommendationService.EnhancedMediaItem>,
        limit: Int = NlpConfig.MAX_RECOMMENDATIONS
    ): List<RecommendationResult> = withContext(Dispatchers.Default) {
        
        // Get or create user profile
        val userProfile = userProfiles.getOrPut(userId) { UserProfile(userId) }
        
        // Calculate scores for each candidate
        val scoredItems = candidateItems.map { item ->
            val enhancedItem = enhancedItems.find { it.originalItem.ratingKey == item.ratingKey }
            val score = calculateRecommendationScore(item, enhancedItem, userProfile)
            
            RecommendationResult(
                mediaItem = item,
                enhancedItem = enhancedItem,
                score = score,
                explanation = generateExplanation(item, enhancedItem, userProfile, score)
            )
        }
        
        // Apply diversity optimization
        val diversifiedResults = applyDiversityOptimization(scoredItems, limit)
        
        // Update user profile with recommendations
        updateUserProfile(userProfile, diversifiedResults.take(limit))
        
        return@withContext diversifiedResults.take(limit)
    }
    
    /**
     * Update user behavior data
     */
    suspend fun recordUserInteraction(
        userId: String,
        mediaItem: PlexMediaItem,
        interactionType: InteractionType,
        watchDurationMs: Long? = null
    ) {
        val userProfile = userProfiles.getOrPut(userId) { UserProfile(userId) }
        
        when (interactionType) {
            InteractionType.VIEWED -> {
                userProfile.addViewedItem(mediaItem)
                watchDurationMs?.let { duration ->
                    userProfile.addWatchDuration(mediaItem.ratingKey ?: "", duration)
                }
            }
            InteractionType.LIKED -> {
                userProfile.addLikedItem(mediaItem)
            }
            InteractionType.DISLIKED -> {
                userProfile.addDislikedItem(mediaItem)
            }
            InteractionType.SHARED -> {
                userProfile.addSharedItem(mediaItem)
            }
            InteractionType.SKIPPED -> {
                userProfile.addSkippedItem(mediaItem)
            }
        }
        
        // Update global statistics
        val key = mediaItem.ratingKey ?: return
        val stats = globalWatchStats.getOrPut(key) { WatchStats() }
        stats.recordInteraction(interactionType)
        
        // Periodically update recommendation weights
        if (Random.nextInt(100) == 0) {
            updateRecommendationWeights()
        }
    }
    
    /**
     * Get similar items based on collaborative filtering
     */
    suspend fun getCollaborativeRecommendations(
        targetItem: PlexMediaItem,
        userId: String,
        limit: Int = 20
    ): List<PlexMediaItem> = withContext(Dispatchers.Default) {
        
        val userProfile = userProfiles[userId] ?: return@withContext emptyList()
        val targetKey = targetItem.ratingKey ?: return@withContext emptyList()
        
        // Find users who watched similar content
        val similarUsers = findSimilarUsers(userProfile, targetItem)
        
        // Get items liked by similar users but not watched by current user
        val candidateItems = similarUsers
            .flatMap { similarUser ->
                similarUser.likedItems.filter { item ->
                    item.ratingKey !in userProfile.viewedItemKeys
                }
            }
            .groupBy { it.ratingKey }
            .mapValues { it.value.first() } // Deduplicate
            .values.toList()
        
        // Score candidates based on collaborative filtering
        val scoredCandidates = candidateItems.map { item ->
            val score = calculateCollaborativeScore(item, similarUsers, userProfile)
            item to score
        }
        
        return@withContext scoredCandidates
            .sortedByDescending { it.second }
            .take(limit)
            .map { it.first }
    }
    
    /**
     * Apply temporal weighting to recommendations
     */
    private suspend fun applyTemporalWeighting(
        items: List<RecommendationResult>
    ): List<RecommendationResult> = withContext(Dispatchers.Default) {
        val now = System.currentTimeMillis()
        val oneWeekMs = 7 * 24 * 60 * 60 * 1000L
        
        return@withContext items.map { result ->
            val item = result.mediaItem
            val itemAgeMs = now - (item.addedAt ?: 0)
            val weeksOld = itemAgeMs.toFloat() / oneWeekMs.toFloat()
            
            // Exponential decay with weekly half-life
            val temporalScore = exp(-weeksOld * ln(2.0f)).toFloat()
            
            result.copy(
                score = result.score * (1 + temporalWeight * temporalScore)
            )
        }
    }
    
    /**
     * Optimize for diversity in recommendations
     */
    private suspend fun applyDiversityOptimization(
        items: List<RecommendationResult>,
        limit: Int
    ): List<RecommendationResult> = withContext(Dispatchers.Default) {
        if (items.size <= limit) return@withContext items
        
        val selected = mutableListOf<RecommendationResult>()
        val remaining = items.toMutableList()
        
        while (selected.size < limit && remaining.isNotEmpty()) {
            // Pick best remaining item considering diversity
            val bestItem = remaining.maxByOrNull { candidate ->
                val baseScore = candidate.score
                val diversityPenalty = calculateDiversityPenalty(candidate, selected)
                baseScore * (1 - diversityWeight * diversityPenalty)
            }
            
            bestItem?.let { item ->
                selected.add(item)
                remaining.remove(item)
            }
        }
        
        return@withContext selected
    }
    
    /**
     * Calculate main recommendation score
     */
    private fun calculateRecommendationScore(
        item: PlexMediaItem,
        enhancedItem: PlexAiRecommendationService.EnhancedMediaItem?,
        userProfile: UserProfile
    ): Float {
        var score = 0f
        
        // Semantic similarity to user preferences
        enhancedItem?.let { enhanced ->
            val semanticScore = calculateSemanticMatch(enhanced, userProfile)
            score += semanticWeight * semanticScore
        }
        
        // Collaborative filtering score
        val collaborativeScore = calculateCollaborativeScore(item, emptyList(), userProfile)
        score += collaborativeWeight * collaborativeScore
        
        // Popularity score (global watch statistics)
        val popularityScore = calculatePopularityScore(item)
        score += 0.1f * popularityScore
        
        // Freshness score
        val freshnessScore = calculateFreshnessScore(item)
        score += temporalWeight * freshnessScore
        
        return score.coerceIn(0f, 1f)
    }
    
    private fun calculateSemanticMatch(
        enhancedItem: PlexAiRecommendationService.EnhancedMediaItem,
        userProfile: UserProfile
    ): Float {
        // Compare with user's preferred genres and keywords
        val genreMatch = calculateGenreMatch(enhancedItem, userProfile)
        val keywordMatch = calculateKeywordMatch(enhancedItem, userProfile)
        
        return (genreMatch + keywordMatch) / 2f
    }
    
    private fun calculateGenreMatch(
        enhancedItem: PlexAiRecommendationService.EnhancedMediaItem,
        userProfile: UserProfile
    ): Float {
        val itemGenres = enhancedItem.metadataAnalysis?.genres?.toSet() ?: emptySet()
        val preferredGenres = userProfile.preferredGenres.toSet()
        
        if (preferredGenres.isEmpty()) return 0.5f // No preference data
        
        val intersection = itemGenres intersect preferredGenres
        val union = itemGenres union preferredGenres
        
        return if (union.isNotEmpty()) {
            intersection.size.toFloat() / union.size.toFloat()
        } else 0f
    }
    
    private fun calculateKeywordMatch(
        enhancedItem: PlexAiRecommendationService.EnhancedMediaItem,
        userProfile: UserProfile
    ): Float {
        val itemKeywords = enhancedItem.metadataAnalysis?.keywords?.toSet() ?: emptySet()
        val preferredKeywords = userProfile.preferredKeywords.toSet()
        
        if (preferredKeywords.isEmpty()) return 0.5f
        
        val intersection = itemKeywords intersect preferredKeywords
        return if (preferredKeywords.isNotEmpty()) {
            intersection.size.toFloat() / preferredKeywords.size.toFloat()
        } else 0f
    }
    
    private fun calculateCollaborativeScore(
        item: PlexMediaItem,
        similarUsers: List<UserProfile>,
        userProfile: UserProfile
    ): Float {
        val itemKey = item.ratingKey ?: return 0f
        
        // Find users who interacted with this item
        val itemInteractions = globalWatchStats[itemKey] ?: return 0f
        
        // Calculate score based on similar users' interactions
        val similarUserScores = similarUsers.map { similarUser ->
            val userInteraction = similarUser.getInteractionScore(itemKey)
            val userSimilarity = calculateUserSimilarity(userProfile, similarUser)
            userInteraction * userSimilarity
        }
        
        return if (similarUserScores.isNotEmpty()) {
            similarUserScores.average().toFloat()
        } else {
            0f
        }
    }
    
    private fun calculatePopularityScore(item: PlexMediaItem): Float {
        val key = item.ratingKey ?: return 0f
        val stats = globalWatchStats[key] ?: return 0f
        
        // Normalize popularity score (0-1 range)
        val maxViews = globalWatchStats.values.maxOfOrNull { it.viewCount } ?: 1
        return if (maxViews > 0) {
            stats.viewCount.toFloat() / maxViews.toFloat()
        } else 0f
    }
    
    private fun calculateFreshnessScore(item: PlexMediaItem): Float {
        val now = System.currentTimeMillis()
        val addedAt = item.addedAt ?: 0L
        val ageHours = (now - addedAt) / (60 * 60 * 1000f)
        
        // Exponential decay over time (24-hour half-life)
        return exp(-ageHours / 24f).toFloat()
    }
    
    private fun calculateDiversityPenalty(
        candidate: RecommendationResult,
        selected: List<RecommendationResult>
    ): Float {
        if (selected.isEmpty()) return 0f
        
        val candidateGenres = candidate.enhancedItem?.metadataAnalysis?.genres?.toSet() ?: emptySet()
        
        // Calculate genre overlap with already selected items
        val totalOverlap = selected.sumOf { selected ->
            val selectedGenres = selected.enhancedItem?.metadataAnalysis?.genres?.toSet() ?: emptySet()
            val overlap = candidateGenres intersect selectedGenres
            overlap.size.toFloat()
        }
        
        // Normalize by number of selected items
        val averageOverlap = totalOverlap / selected.size.toFloat()
        val maxPossibleOverlap = candidateGenres.size.toFloat()
        
        return if (maxPossibleOverlap > 0) {
            averageOverlap / maxPossibleOverlap
        } else 0f
    }
    
    private fun calculateUserSimilarity(user1: UserProfile, user2: UserProfile): Float {
        val commonViewed = user1.viewedItemKeys intersect user2.viewedItemKeys
        val totalViewed = user1.viewedItemKeys union user2.viewedItemKeys
        
        return if (totalViewed.isNotEmpty()) {
            commonViewed.size.toFloat() / totalViewed.size.toFloat()
        } else 0f
    }
    
    private fun findSimilarUsers(userProfile: UserProfile, targetItem: PlexMediaItem): List<UserProfile> {
        val targetKey = targetItem.ratingKey ?: return emptyList()
        
        return userProfiles.values
            .filter { it.userId != userProfile.userId }
            .filter { it.hasViewed(targetKey) }
            .map { similarUser ->
                similarUser to calculateUserSimilarity(userProfile, similarUser)
            }
            .sortedByDescending { it.second }
            .take(10) // Top 10 similar users
            .map { it.first }
    }
    
    private fun generateExplanation(
        item: PlexMediaItem,
        enhancedItem: PlexAiRecommendationService.EnhancedMediaItem?,
        userProfile: UserProfile,
        score: Float
    ): String {
        val explanations = mutableListOf<String>()
        
        // Semantic explanation
        enhancedItem?.let { enhanced ->
            val matchingGenres = enhanced.metadataAnalysis?.genres?.filter { 
                it in userProfile.preferredGenres 
            }?.take(3) ?: emptyList()
            
            if (matchingGenres.isNotEmpty()) {
                explanations.add("Matches your interest in ${matchingGenres.joinToString(", ")}")
            }
        }
        
        // Popularity explanation
        val popularityScore = calculatePopularityScore(item)
        if (popularityScore > 0.7f) {
            explanations.add("Popular among other users")
        }
        
        // Freshness explanation
        val freshnessScore = calculateFreshnessScore(item)
        if (freshnessScore > 0.8f) {
            explanations.add("Recently added")
        }
        
        // Collaborative explanation
        val collaborativeScore = calculateCollaborativeScore(item, emptyList(), userProfile)
        if (collaborativeScore > 0.6f) {
            explanations.add("Users like you enjoyed this")
        }
        
        return if (explanations.isNotEmpty()) {
            explanations.joinToString("; ")
        } else {
            "Recommended based on your viewing history"
        }
    }
    
    private fun updateUserProfile(userProfile: UserProfile, recommendations: List<RecommendationResult>) {
        // Update preferences based on recommendations
        recommendations.forEach { recommendation ->
            recommendation.enhancedItem?.metadataAnalysis?.let { analysis ->
                // Update genre preferences
                analysis.genres.forEach { genre ->
                    userProfile.incrementGenrePreference(genre)
                }
                
                // Update keyword preferences
                analysis.keywords.take(5).forEach { keyword ->
                    userProfile.incrementKeywordPreference(keyword)
                }
            }
        }
        
        // Normalize preference weights
        userProfile.normalizePreferences()
    }
    
    private fun updateRecommendationWeights() {
        // Implement machine learning to update weights based on user feedback
        // This is a simplified version - in production, use actual ML algorithms
        
        val averageSemanticScore = userProfiles.values.map { it.semanticSatisfaction }.average().toFloat()
        val averageCollaborativeScore = userProfiles.values.map { it.collaborativeSatisfaction }.average().toFloat()
        
        // Adjust weights based on satisfaction
        semanticWeight = 0.5f + (averageSemanticScore - 0.5f) * 0.2f
        collaborativeWeight = 0.3f + (averageCollaborativeScore - 0.5f) * 0.2f
        
        // Ensure weights sum to 1
        val totalWeight = semanticWeight + collaborativeWeight + temporalWeight + diversityWeight
        if (totalWeight > 0) {
            semanticWeight /= totalWeight
            collaborativeWeight /= totalWeight
            temporalWeight /= totalWeight
            diversityWeight /= totalWeight
        }
    }
    
    data class RecommendationResult(
        val mediaItem: PlexMediaItem,
        val enhancedItem: PlexAiRecommendationService.EnhancedMediaItem?,
        val score: Float,
        val explanation: String
    )
    
    data class UserProfile(
        val userId: String,
        var viewedItemKeys: MutableSet<String> = mutableSetOf(),
        var likedItems: MutableSet<PlexMediaItem> = mutableSetOf(),
        var dislikedItems: MutableSet<PlexMediaItem> = mutableSetOf(),
        var sharedItems: MutableSet<PlexMediaItem> = mutableSetOf(),
        var skippedItems: MutableSet<PlexMediaItem> = mutableSetOf(),
        var preferredGenres: MutableMap<String, Float> = mutableMapOf(),
        var preferredKeywords: MutableMap<String, Float> = mutableMapOf(),
        var watchDurations: MutableMap<String, Long> = mutableMapOf(),
        var semanticSatisfaction: Float = 0.5f,
        var collaborativeSatisfaction: Float = 0.5f
    ) {
        fun addViewedItem(item: PlexMediaItem) {
            val key = item.ratingKey ?: return
            viewedItemKeys.add(key)
        }
        
        fun addLikedItem(item: PlexMediaItem) {
            likedItems.add(item)
            incrementGenreSatisfaction(item, 0.1f)
        }
        
        fun addDislikedItem(item: PlexMediaItem) {
            dislikedItems.add(item)
            incrementGenreSatisfaction(item, -0.1f)
        }
        
        fun addSharedItem(item: PlexMediaItem) {
            sharedItems.add(item)
            incrementGenreSatisfaction(item, 0.05f)
        }
        
        fun addSkippedItem(item: PlexMediaItem) {
            skippedItems.add(item)
            incrementGenreSatisfaction(item, -0.05f)
        }
        
        fun addWatchDuration(key: String, durationMs: Long) {
            watchDurations[key] = durationMs
        }
        
        fun hasViewed(key: String): Boolean = key in viewedItemKeys
        
        fun getInteractionScore(key: String): Float {
            return when {
                key in likedItems.mapNotNull { it.ratingKey } -> 1.0f
                key in viewedItemKeys -> 0.5f
                key in dislikedItems.mapNotNull { it.ratingKey } -> 0.0f
                else -> 0.0f
            }
        }
        
        fun incrementGenrePreference(genre: String) {
            preferredGenres[genre] = (preferredGenres[genre] ?: 0f) + 1f
        }
        
        fun incrementKeywordPreference(keyword: String) {
            preferredKeywords[keyword] = (preferredKeywords[keyword] ?: 0f) + 0.5f
        }
        
        fun incrementGenreSatisfaction(item: PlexMediaItem, delta: Float) {
            // Simplified - in production, extract genre from item metadata
            semanticSatisfaction = (semanticSatisfaction + delta).coerceIn(0f, 1f)
        }
        
        fun normalizePreferences() {
            val maxGenreWeight = preferredGenres.values.maxOrNull() ?: 1f
            val maxKeywordWeight = preferredKeywords.values.maxOrNull() ?: 1f
            
            preferredGenres.keys.forEach { genre ->
                preferredGenres[genre] = (preferredGenres[genre] ?: 0f) / maxGenreWeight
            }
            
            preferredKeywords.keys.forEach { keyword ->
                preferredKeywords[keyword] = (preferredKeywords[keyword] ?: 0f) / maxKeywordWeight
            }
        }
    }
    
    data class WatchStats(
        var viewCount: Long = 0L,
        var likeCount: Long = 0L,
        var dislikeCount: Long = 0L,
        var shareCount: Long = 0L,
        var skipCount: Long = 0L
    ) {
        fun recordInteraction(type: InteractionType) {
            when (type) {
                InteractionType.VIEWED -> viewCount++
                InteractionType.LIKED -> likeCount++
                InteractionType.DISLIKED -> dislikeCount++
                InteractionType.SHARED -> shareCount++
                InteractionType.SKIPPED -> skipCount++
            }
        }
    }
    
    enum class InteractionType {
        VIEWED, LIKED, DISLIKED, SHARED, SKIPPED
    }
}